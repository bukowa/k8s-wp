image:
  wordpress: wordpress:6.0.3-php7.4-apache
  mariadb: mariadb:10.9.3
  wpcli: wordpress:cli-php7.4

web:
  host: wp.doma
  url: http://wp.doma

plugins:
  - woocommerce
  - bbpress

themes:

# scripts executed only if WordPress is not installed
wordpress_init:
  - wp plugin delete hello || true
  - wp plugin delete akismet || true
  - wp theme delete twentynineteen || true
  - wp theme delete twentyseventeen || true
  - wp theme delete twentysixteen || true
  - wp rewrite structure '/%category%/%postname%/'

# scripts executed each time Pod is started
wordpress_start:
  - /scripts/wordpress-install.sh

database:
  user: "example"
  password: "example"
  name: "example"
  rootPassword: "example"

# each file ownership is set to root:root
# unless securityContext; runAsGroup and runAsUser is used
# from docs;
# By default, Kubernetes recursively changes ownership and permissions
# for the contents of each volume to match the fsGroup specified in a
# Pod's securityContext when that volume is mounted.

# for reff
# https://github.com/kubernetes/kubernetes/issues/81089
# https://stackoverflow.com/questions/49945437/changing-default-file-owner-and-group-owner-of-kubernetes-secrets-files-mounted

# using dict instead of list allows us to override each entry
files:

  # name of the Volume & data key in ConfigMap
  # name of this key doesn't matter other than providing unique name
  user-ini:
    filemode: "0444"
    content: |
        upload_max_filesize = 5000M
        post_max_size = 5000M
        cgi.fix_pathinfo = 0
        memory_limit = 128M
    containers:
      wordpress:
        - mountPath: "/usr/local/etc/php/conf.d/user.ini"

  mpm-prefork:
    filemode: "0444"
    containers:
      wordpress:
        - mountPath: "/etc/apache2/mods-enabled/mpm_prefork.conf"
    content: |
      <IfModule mpm_prefork_module>
      StartServers		2
      MinSpareServers	2
      MaxSpareServers	4
      MaxRequestWorkers	16
      MaxConnectionsPerChild  2
      </IfModule>

  docker-cnf:
    filemode: "0444"
    containers:
      database:
        - mountPath: /etc/mysql/conf.d/docker.cnf
    content: |
      [mysqld]
      # default_authentication_plugin=mysql_native_password
      skip-host-cache
      skip-name-resolve
  
      # copied for  testing from https://dba.stackexchange.com/questions/64055/how-to-reduce-mysql-memory-used
  
      innodb_buffer_pool_size=5M
      innodb_log_buffer_size=256K
      query_cache_size=0
      max_connections=10
      key_buffer_size=8
      thread_cache_size=0
      host_cache_size=0
      innodb_ft_cache_size=1600000
      innodb_ft_total_cache_size=32000000
  
      # per thread or per operation settings
      # this crashes mariadb
      #thread_stack=131072
      sort_buffer_size=32K
      read_buffer_size=8200
      read_rnd_buffer_size=8200
      max_heap_table_size=16K
      tmp_table_size=1K
      bulk_insert_buffer_size=0
      join_buffer_size=128
      net_buffer_length=1K
      innodb_sort_buffer_size=64K
  
      #settings that relate to the binary log (if enabled)
      binlog_cache_size=4K
      binlog_stmt_cache_size=4K


  wp-install:
    filemode: "0555"
    containers:
      cli:
        - mountPath: /scripts/wordpress-install.sh
    content: |
      #!/bin/bash
      set -eux

      if wp core is-installed;
      then
          echo "Wordpress is already installed..."
      else
          declare -p WORDPRESS_TITLE >/dev/null
          declare -p WORDPRESS_LOGIN >/dev/null
          declare -p WORDPRESS_PASSWORD >/dev/null
          declare -p WORDPRESS_EMAIL >/dev/null
          echo "Installing wordpress on ${WORDPRESS_URL}..."
          wp core install \
              --url=${WORDPRESS_URL} \
              --title=${WORDPRESS_TITLE} \
              --admin_user=${WORDPRESS_LOGIN} \
              --admin_password=${WORDPRESS_PASSWORD} \
              --admin_email=${WORDPRESS_EMAIL} \
              --skip-email
      fi

      CURRENT_DOMAIN=$(wp option get siteurl)

      if ! [[ ${CURRENT_DOMAIN} == "${WORDPRESS_URL}" ]]; then
          echo "Replacing ${CURRENT_DOMAIN} with ${WORDPRESS_URL} in database..."
          wp search-replace "${CURRENT_DOMAIN}" "${WORDPRESS_URL}"
      fi

      echo "Visit $(wp option get siteurl)/wp-login.php"


  wait-for-entrypoint:
    filemode: "0555"
    containers:
      cli:
        - mountPath: /scripts/wait-for-entrypoint.sh
    content: |
      #!/bin/bash
      # source https://github.com/cec/wait-for-endpoint
      #MIT License
      #
      #Copyright (c) 2021 cec
      #
      #Permission is hereby granted, free of charge, to any person obtaining a copy
      #of this software and associated documentation files (the "Software"), to deal
      #in the Software without restriction, including without limitation the rights
      #to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      #copies of the Software, and to permit persons to whom the Software is
      #furnished to do so, subject to the following conditions:
      #
      #The above copyright notice and this permission notice shall be included in all
      #copies or substantial portions of the Software.
      #
      #THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      #IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      #FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      #AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      #LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      #OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      #SOFTWARE.
      #
      # Waits until request to given URI returns 200 or timeout threshold is reached.
      # Can be given a command to run when done waiting.
      #

      SCRIPT_NAME=${0##*/}

      echoerr() { if [[ $QUIET -ne 1 ]]; then echo "$@" 1>&2; fi }

      usage()
      {
          cat << USAGE >&2
      Usage:
          $SCRIPT_NAME uri [-s] [-t timeout] [-- COMMAND ARGS]
          uri                         a valid http(s) URI
          -s | --strict               Only execute COMMAND if the test succeeds
          -q | --quiet                Don't output any status messages
          -c | --code                 Expected HTTP status code
          -t TIMEOUT | --timeout=TIMEOUT
                                      Timeout in seconds, zero for no timeout
          -- COMMAND ARGS             Command with args to run after the test finishes
      USAGE
          exit 1
      }

      wait_for()
      {
          if [[ $TIMEOUT -gt 0 ]]; then
              echoerr "$SCRIPT_NAME: waiting $TIMEOUT seconds for $URI to get a $EXPECTEDCODE HTTP code"
          else
              echoerr "$SCRIPT_NAME: waiting for $URI without a timeout"
          fi
          WAIT_START_TS=$(date +%s)
          while :
          do
                  STATUS_CODE=$(curl --connect-timeout 2 --insecure -s -o /dev/null -w ''%{http_code}'' $URI)
                  test "$STATUS_CODE" == "$EXPECTEDCODE"
                  OUTCOME=$?
              if [[ $OUTCOME -eq 0 ]]; then
                  WAIT_END_TS=$(date +%s)
                  echoerr "$SCRIPT_NAME: $URI is alive after $((WAIT_END_TS - WAIT_START_TS)) seconds"
                  break
              fi
              sleep 1
          done
          return $OUTCOME
      }

      # passes this script and its arguments to timeout (the script calls itself inside a timeout context)
      wait_for_wrapper()
      {
          # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
          if [[ $QUIET -eq 1 ]]; then
              timeout $BUSY_BOX_TIMEFLAG $TIMEOUT $0 $URI --quiet --child --timeout=$TIMEOUT --code=$EXPECTEDCODE &
          else
              timeout $BUSY_BOX_TIMEFLAG $TIMEOUT $0 $URI --child --timeout=$TIMEOUT --code=$EXPECTEDCODE &
          fi
          SUBPROCESS_PID=$!
          trap "kill -INT -$SUBPROCESS_PID" INT
          wait $SUBPROCESS_PID
          OUTCOME=$?
          if [[ $OUTCOME -ne 0 ]]; then
              echoerr "$SCRIPT_NAME: timeout occurred after waiting $TIMEOUT seconds for $URI"
          fi
          return $OUTCOME
      }

      validate_uri()
      {
          curl --connect-timeout 1 --insecure -s -o /dev/null $URI
          curl_exit_code=$?
          if [[ $curl_exit_code -eq 3 ]]; then # exit code 3 indicates an invalid URI
              echoerr "Error: you need to provide a VALID URI to test."
              usage
          fi
      }

      # process arguments
      while [[ $# -gt 0 ]]
      do
          case "$1" in
              http://*)
              URI="$1"
              if [[ $URI == "" ]]; then break; fi
              shift 1
              ;;
              https://*)
              URI="$1"
              if [[ $URI == "" ]]; then break; fi
              shift 1
              ;;
              --child)
              CHILD=1
              shift 1
              ;;
              -q | --quiet)
              QUIET=1
              shift 1
              ;;
              -s | --strict)
              STRICT=1
              shift 1
              ;;
              -c)
              EXPECTEDCODE="$2"
              if [[ $EXPECTEDCODE == "" ]]; then break; fi
              shift 2
              ;;
              --code=*)
              EXPECTEDCODE="${1#*=}"
              shift 1
              ;;
              -t)
              TIMEOUT="$2"
              if [[ $TIMEOUT == "" ]]; then break; fi
              shift 2
              ;;
              --timeout=*)
              TIMEOUT="${1#*=}"
              shift 1
              ;;
              --)
              shift
              COMMAND=("$@")
              break
              ;;
              -h)
              usage
              ;;
              --help)
              usage
              ;;
              *)
              echoerr "Unknown argument: $1"
              usage
              ;;
          esac
      done

      # make sure that uri was given and is valid (by testing for curl exit code 3)
      if [[ "$URI" == "" ]]; then
          echoerr "Error: you need to provide a URI to test."
          usage
      fi
      validate_uri

      TIMEOUT=${TIMEOUT:-15}
      STRICT=${STRICT:-0}
      EXPECTEDCODE=${EXPECTEDCODE:-200}
      CHILD=${CHILD:-0}
      QUIET=${QUIET:-0}

      # Check to see if timeout is from busybox?
      TIMEOUT_PATH=$(type -p timeout)
      TIMEOUT_PATH=$(realpath $TIMEOUT_PATH 2>/dev/null || readlink -f $TIMEOUT_PATH)

      BUSY_BOX_TIMEFLAG=""
      if [[ $TIMEOUT_PATH =~ "busybox" ]]; then
          ON_BUSY_BOX=1
          # Check if busybox timeout uses -t flag
          # (recent Alpine versions don't support -t anymore)
          if timeout &>/dev/stdout | grep -q -e '-t '; then
              BUSY_BOX_TIMEFLAG="-t"
          fi
      else
          ON_BUSY_BOX=0
      fi

      if [[ $CHILD -gt 0 ]]; then
          wait_for
          OUTCOME=$?
          exit $OUTCOME
      else
          if [[ $TIMEOUT -gt 0 ]]; then
              wait_for_wrapper
              OUTCOME=$?
          else
              wait_for
              OUTCOME=$?
          fi
      fi

      if [[ $COMMAND != "" ]]; then
          if [[ $OUTCOME -ne 0 && $STRICT -eq 1 ]]; then
              echoerr "$SCRIPT_NAME: strict mode, refusing to execute subprocess"
              exit $OUTCOME
          fi
          exec "${COMMAND[@]}"
      else
          exit $OUTCOME
      fi







ftp:
  enabled: false
  login: test
  password: test
